%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint,nocopyrightspace,10pt]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\input{macros}
\usepackage{amsmath}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{colorlinks=true,citecolor=cyan}

\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2005} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Examining the Connection Between Hardware Architecture and Virtual Machine Design}
%\subtitle{Subtitle Text, if any}

%\authorinfo{Name1}
%           {Affiliation1}
%           {Email1}
\authorinfo{Ethan A. Kuefner\and Madhukar N. Kedlaya}
           {University of California, Santa Barbara}
           {\{eakuefner,mkedlaya\}@cs.ucsb.edu}

\maketitle

%TODO: Remove papers from this list as they are cited.
\nocite{lin11,wegiel08,sullivan03,jo12}

\begin{abstract}
Virtual machines for programming language interpretation have become popular despite the long-standing generality
that compiled code is faster than interpreted code. By viewing interpreters as virtual machines, we can exploit
the similarity between virtual machines and the underlying hardware architectures on which they run to take
advantage of optimizations implicit in hardware and improve the performance of virtual machines. In this paper,
branch prediction and spatial locality are reviewed as two critical optimizations to be exploited by VMs.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

%\terms
%term1, term2

%\keywords
%keyword1, keyword2

\input{intro.tex}
\input{branchPrediction.tex}
\input{caching.tex}
% We recommend abbrvnat bibliography style.
\pagebreak
\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\bibliography{paper.bib}

\appendix
\section{Sample Homework Problem}
\href{https://bitbucket.org/eakuefner/cs162interpreter}{Here} is a working bytecode compiler and interpreter toolchain for a
simple programming language, written in C++. Use this DynamoRIO \href{http://www.dynamorio.org/tutorial.html}{tutorial} to
instrument the interpreter with hooks for straight-line code as described in this paper, and then compare the performance
with and without the tracer enabled. What is the speedup that you observe?

\section{More Ideas}
In this appendix we list a number of additional ideas along these lines that we might be interested in exploring. You know how
to reach us!
\begin{itemize}
\item What does it mean to design instruction caches for functional programs? Are there additional invariants of programs in
languages like Haskell that we might exploit?
\item Above we discussed hinting hardware branch predictors---could the same reasoning be applied to caching? In other words,
would it be possible to design hardware to which a programmer could indicate that they plan on later using a chunk of memory,
or using a chunk of memory particularly frequently?
\item Would it be possible to design hardware features that remove some of the complexities that make adaptive/realtime program
analyses difficult?
\item Could we design a system for context-sensitive memory access reordering? In other words, could we apply something like in
\cite{jo12} to hardware memory access reordering?
\end{itemize}
\end{document}
